{
  "version": 3,
  "sources": ["../src/lib/split.ts", "../src/lib/search-constraints.ts", "../src/lib/parse.ts", "../src/lib/href.ts", "../src/lib/stringify.ts", "../src/lib/join.ts", "../src/lib/route-pattern.ts", "../src/lib/regexp-matcher.ts", "../src/lib/trie-matcher.ts"],
  "sourcesContent": ["type Range = [number, number] // [start (inclusive), end (exclusive)]\n\nexport interface SplitResult {\n  protocol: Range | undefined\n  hostname: Range | undefined\n  port: Range | undefined\n  pathname: Range | undefined\n  search: Range | undefined\n}\n\n/**\n * Split a route pattern into protocol, hostname, port, pathname, and search\n * ranges. Ranges are [start (inclusive), end (exclusive)].\n */\nexport function split<T extends string>(source: T): SplitResult {\n  let protocol: Range | undefined\n  let hostname: Range | undefined\n  let port: Range | undefined\n  let pathname: Range | undefined\n  let search: Range | undefined\n\n  // search\n  let searchStart = source.indexOf('?')\n  if (searchStart !== -1) {\n    search = [searchStart + 1, source.length]\n    source = source.slice(0, searchStart) as T\n  }\n\n  let index = 0\n  let solidusIndex = source.indexOf('://')\n  if (solidusIndex !== -1) {\n    // protocol\n    if (solidusIndex !== 0) {\n      protocol = [0, solidusIndex]\n    }\n    index = solidusIndex + 3\n\n    // hostname + port\n    let hostEndIndex = source.indexOf('/', index)\n    if (hostEndIndex === -1) hostEndIndex = source.length\n\n    // detect port (numeric) at end of host segment\n    let colonIndex = source.lastIndexOf(':', hostEndIndex - 1)\n    if (colonIndex !== -1 && colonIndex >= index) {\n      // Ensure everything after the colon is digits\n      let isPort = true\n      for (let i = colonIndex + 1; i < hostEndIndex; i++) {\n        let char = source.charCodeAt(i)\n        if (char < 48 /* '0' */ || char > 57 /* '9' */) {\n          isPort = false\n          break\n        }\n      }\n\n      if (isPort && colonIndex + 1 < hostEndIndex) {\n        // hostname up to colon, port after colon\n        hostname = [index, colonIndex]\n        port = [colonIndex + 1, hostEndIndex]\n      } else {\n        hostname = [index, hostEndIndex]\n      }\n    } else {\n      hostname = [index, hostEndIndex]\n    }\n\n    index = hostEndIndex === source.length ? hostEndIndex : hostEndIndex + 1\n  }\n\n  // pathname\n  if (index !== source.length) {\n    if (source.charAt(index) === '/') {\n      index += 1\n    }\n\n    pathname = [index, source.length]\n  }\n\n  return { protocol, hostname, port, pathname, search }\n}\n\nexport interface SplitPattern {\n  protocol: string | undefined\n  hostname: string | undefined\n  port: string | undefined\n  pathname: string | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Split<T extends string> =\n  _Split<T> extends infer S extends Partial<SplitPattern> ? {\n    protocol: S['protocol'] extends string ? S['protocol'] : undefined\n    hostname: S['hostname'] extends string ? S['hostname'] : undefined\n    port: S['port'] extends string ? S['port'] : undefined\n    pathname: S['pathname'] extends string ? S['pathname'] : undefined\n    search: S['search'] extends string ? S['search'] : undefined\n  } :\n  never\n\n// prettier-ignore\ntype _Split<T extends string> =\n  T extends '' ? {} :\n  T extends `${infer L}?${infer R}` ? _Split<L> & { search: R } :\n  T extends `${infer Protocol}://${infer R}` ?\n    Protocol extends '' ? (\n      R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { pathname: Pathname } :\n      SplitHost<R>\n    ) :\n    Protocol extends `${string}/${string}` ? { pathname: T } :\n    R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { protocol: Protocol; pathname: Pathname } :\n    SplitHost<R> & { protocol: Protocol } :\n  T extends `/${infer Pathname}` ? { pathname: Pathname } :\n  { pathname: T }\n\n// prettier-ignore\ntype SplitHost<T extends string> =\n  T extends `${infer L}:${infer R}` ?\n    IsDigits<R> extends true ? { hostname: L; port: R} :\n    SplitHost<R> extends { hostname: infer H extends string; port: infer P extends string } ? { hostname: `${L}:${H}`; port: P } :\n    { hostname: T } :\n  { hostname: T }\n\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\n// prettier-ignore\ntype IsDigits<S extends string> =\n  S extends `${_0_9}${infer T}` ?\n    T extends '' ? true :\n    IsDigits<T> :\n  false\n", "export type SearchConstraints = Map<\n  string,\n  { requiredValues?: Set<string>; requireAssignment: boolean; allowBare: boolean }\n>\n\nexport function parseSearchConstraints(search: string): SearchConstraints {\n  let constraints: SearchConstraints = new Map()\n\n  for (let part of search.split('&')) {\n    if (part === '') continue\n    let eqIndex = part.indexOf('=')\n    if (eqIndex === -1) {\n      // Presence-only (no '=')\n      let name = decodeSearchComponent(part)\n      let existing = constraints.get(name)\n      if (!existing) {\n        constraints.set(name, { requireAssignment: false, allowBare: true })\n      }\n      continue\n    }\n\n    let name = decodeSearchComponent(part.slice(0, eqIndex))\n    let valuePart = part.slice(eqIndex + 1)\n    let existing = constraints.get(name)\n    if (!existing) {\n      existing = { requireAssignment: true, allowBare: false }\n      constraints.set(name, existing)\n    } else {\n      existing.requireAssignment = true\n      existing.allowBare = false\n    }\n\n    if (valuePart.length > 0) {\n      let decodedValue = decodeSearchComponent(valuePart)\n      if (!existing.requiredValues) existing.requiredValues = new Set<string>()\n      existing.requiredValues.add(decodedValue)\n    }\n  }\n\n  return constraints\n}\n\nexport function parseSearch(search: string): {\n  namesWithoutAssignment: Set<string>\n  namesWithAssignment: Set<string>\n  valuesByKey: Map<string, Set<string>>\n} {\n  if (search.startsWith('?')) search = search.slice(1)\n\n  let namesWithoutAssignment = new Set<string>(),\n    namesWithAssignment = new Set<string>(),\n    valuesByKey = new Map<string, Set<string>>()\n\n  if (search.length > 0) {\n    for (let part of search.split('&')) {\n      if (part === '') continue\n      let eqIndex = part.indexOf('=')\n      if (eqIndex === -1) {\n        let name = decodeSearchComponent(part)\n        namesWithoutAssignment.add(name)\n        continue\n      }\n\n      let name = decodeSearchComponent(part.slice(0, eqIndex))\n      let valuePart = part.slice(eqIndex + 1)\n      namesWithAssignment.add(name)\n      let value = decodeSearchComponent(valuePart)\n      let set = valuesByKey.get(name) ?? new Set<string>()\n      if (!valuesByKey.has(name)) valuesByKey.set(name, set)\n      set.add(value)\n    }\n  }\n\n  return { namesWithoutAssignment, namesWithAssignment, valuesByKey }\n}\n\nfunction decodeSearchComponent(text: string): string {\n  try {\n    return decodeURIComponent(text.replace(/\\+/g, ' '))\n  } catch {\n    return text\n  }\n}\n", "import { split } from './split.ts'\nimport type { SplitPattern, Split } from './split.ts'\nimport { parseSearchConstraints } from './search-constraints.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport class ParseError extends Error {\n  source: string\n  position: number\n  partName: string\n\n  constructor(description: string, partName: string, source: string, position: number) {\n    super(`${description} in ${partName}`)\n    this.name = 'ParseError'\n    this.source = source\n    this.position = position\n    this.partName = partName\n  }\n}\n\nexport interface ParseResult {\n  protocol: Array<Token> | undefined\n  hostname: Array<Token> | undefined\n  port: string | undefined\n  pathname: Array<Token> | undefined\n  search: string | undefined\n  searchConstraints: SearchConstraints | undefined\n}\n\nexport function parse<T extends string>(source: T): ParseResult {\n  let protocol: Token[] | undefined\n  let hostname: Token[] | undefined\n  let port: string | undefined\n  let pathname: Token[] | undefined\n  let search: string | undefined\n  let searchConstraints: SearchConstraints | undefined\n\n  let ranges = split(source)\n\n  if (ranges.protocol) {\n    protocol = parsePart('protocol', '', source, ...ranges.protocol)\n  }\n  if (ranges.hostname) {\n    hostname = parsePart('hostname', '.', source, ...ranges.hostname)\n  }\n  if (ranges.port) {\n    port = source.slice(...ranges.port)\n  }\n  if (ranges.pathname) {\n    pathname = parsePart('pathname', '/', source, ...ranges.pathname)\n  }\n  if (ranges.search) {\n    search = source.slice(...ranges.search)\n    searchConstraints = parseSearchConstraints(search)\n  }\n\n  return { protocol, hostname, port, pathname, search, searchConstraints }\n}\n\nconst identifierMatcher = /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\nfunction parsePart(partName: string, sep: string, source: string, start: number, end: number) {\n  let tokens: Token[] = []\n  let currentTokens = tokens\n  // Use a simple stack of token arrays: the top is where new tokens are appended.\n  // The root of the stack is the `part` array. Each '(' pushes a new array; ')'\n  // pops and wraps it in an optional token which is appended to the new top.\n  let tokensStack: Array<Token[]> = [tokens]\n  let openIndexes: Array<number> = []\n\n  let appendText = (text: string) => {\n    let lastToken = currentTokens.at(-1)\n    if (lastToken?.type === 'text') {\n      lastToken.value += text\n    } else {\n      currentTokens.push({ type: 'text', value: text })\n    }\n  }\n\n  let i = start\n  while (i < end) {\n    let char = source[i]\n\n    // separator\n    if (char === sep) {\n      currentTokens.push({ type: 'separator' })\n      i += 1\n      continue\n    }\n\n    // variable\n    if (char === ':') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (!name) throw new ParseError('missing variable name', partName, source, i)\n      currentTokens.push({ type: 'variable', name })\n      i += name.length\n      continue\n    }\n\n    // wildcard\n    if (char === '*') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (name) {\n        currentTokens.push({ type: 'wildcard', name })\n        i += name.length\n      } else {\n        currentTokens.push({ type: 'wildcard' })\n      }\n      continue\n    }\n\n    // optional\n    if (char === '(') {\n      tokensStack.push((currentTokens = []))\n      openIndexes.push(i)\n      i += 1\n      continue\n    }\n    if (char === ')') {\n      if (tokensStack.length === 1) throw new ParseError('unmatched )', partName, source, i)\n      let tokens = tokensStack.pop()!\n      currentTokens = tokensStack[tokensStack.length - 1]\n      currentTokens.push({ type: 'optional', tokens })\n      openIndexes.pop()\n      i += 1\n      continue\n    }\n\n    // text\n    if (char === '\\\\') {\n      let next = source.at(i + 1)\n      if (!next || i + 1 >= end) throw new ParseError('dangling escape', partName, source, i)\n      appendText(next)\n      i += 2\n      continue\n    }\n\n    appendText(char)\n    i += 1\n  }\n\n  if (openIndexes.length > 0) {\n    // Report the position of the earliest unmatched '('\n    throw new ParseError('unmatched (', partName, source, openIndexes[0])\n  }\n\n  return tokens\n}\n\nexport interface ParsedPattern {\n  protocol: Token[] | undefined\n  hostname: Token[] | undefined\n  port: string | undefined\n  pathname: Token[] | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Parse<T extends string> =\n  [T] extends [string] ?\n    Split<T> extends infer S extends SplitPattern ?\n      {\n        protocol: S['protocol'] extends string ? ParsePart<S['protocol']> : undefined\n        hostname: S['hostname'] extends string ? ParsePart<S['hostname'], '.'> : undefined\n        port: S['port'] extends string ? S['port'] : undefined\n        pathname: S['pathname'] extends string ? ParsePart<S['pathname'], '/'> : undefined\n        search: S['search'] extends string ? S['search'] : undefined\n      } :\n      never :\n    never\n\nexport type Variable = { type: 'variable'; name: string }\nexport type Wildcard = { type: 'wildcard'; name?: string }\nexport type Text = { type: 'text'; value: string }\nexport type Separator = { type: 'separator' }\nexport type Optional = { type: 'optional'; tokens: Token[] }\n\nexport type Token = Variable | Wildcard | Text | Separator | Optional\n\ntype ParsePartState = {\n  tokens: Token[]\n  optionals: Array<Token[]>\n  rest: string\n}\n\ntype ParsePart<T extends string, Sep extends string = ''> = _ParsePart<\n  {\n    tokens: []\n    optionals: []\n    rest: T\n  },\n  Sep\n>\n\n// prettier-ignore\ntype _ParsePart<S extends ParsePartState, Sep extends string = ''> =\n  S extends { rest: `${infer Head}${infer Tail}` } ?\n    Head extends Sep ? _ParsePart<AppendToken<S, { type: 'separator' }, Tail>, Sep> :\n    Head extends ':' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        (name extends '' ? never : _ParsePart<AppendToken<S, { type: 'variable', name: name }, rest>, Sep>) :\n      never : // this should never happen\n    Head extends '*' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        _ParsePart<AppendToken<S, (name extends '' ? { type: 'wildcard' } : { type: 'wildcard', name: name }), rest>, Sep> :\n      never : // this should never happen\n    Head extends '(' ? _ParsePart<PushOptional<S, Tail>, Sep> :\n    Head extends ')' ?\n      PopOptional<S, Tail> extends infer next extends ParsePartState ? _ParsePart<next, Sep> :\n      never : // unmatched `)` handled in PopOptional\n    Head extends '\\\\' ?\n      Tail extends `${infer L}${infer R}` ? _ParsePart<AppendText<S, L, R>, Sep> :\n      never : // dangling escape\n    _ParsePart<AppendText<S, Head, Tail>, Sep> :\n  S['optionals'] extends [] ? S['tokens'] :\n  never // unmatched `(`\n\n// prettier-ignore\ntype AppendToken<S extends ParsePartState, token extends Token, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    {\n      tokens: S['tokens']\n      optionals: [...O, [...Top, token]]\n      rest: rest\n    } :\n    {\n      tokens: [...S['tokens'], token]\n      optionals: S['optionals']\n      rest: rest;\n    }\n\n// prettier-ignore\ntype AppendText<S extends ParsePartState, text extends string, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    (\n      Top extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: S['tokens']; optionals: [...O, [...Tokens, { type: 'text', value: `${value}${text}` }]]; rest: rest } :\n        { tokens: S['tokens']; optionals: [...O, [...Top, { type: 'text', value: text }]]; rest: rest }\n    ) :\n    (\n      S['tokens'] extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: [...Tokens, { type: 'text', value: `${value}${text}` }]; optionals: S['optionals']; rest: rest } :\n        { tokens: [...S['tokens'], { type: 'text', value: text }]; optionals: S['optionals']; rest: rest }\n    )\n\n// Optional stack helpers ---------------------------------------------------------------------------\n\ntype PushOptional<S extends ParsePartState, rest extends string> = {\n  tokens: S['tokens']\n  optionals: [...S['optionals'], []]\n  rest: rest\n}\n\n// If stack is empty -> unmatched ')', return never\n// Else pop and wrap tokens into an Optional token; append to parent or part\ntype PopOptional<S extends ParsePartState, R extends string> = S['optionals'] extends [\n  ...infer O extends Array<Token[]>,\n  infer Top extends Array<Token>,\n]\n  ? O extends [...infer OO extends Array<Token[]>, infer Parent extends Token[]]\n    ? {\n        tokens: S['tokens']\n        optionals: [...OO, [...Parent, { type: 'optional'; tokens: Top }]]\n        rest: R\n      }\n    : { tokens: [...S['tokens'], { type: 'optional'; tokens: Top }]; optionals: []; rest: R }\n  : never\n\n// Identifier --------------------------------------------------------------------------------------\n\n// prettier-ignore\ntype _a_z = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'\ntype _A_Z = Uppercase<_a_z>\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\ntype IdentifierHead = _a_z | _A_Z | '_' | '$'\ntype IdentifierTail = IdentifierHead | _0_9\n\ntype IdentifierParse<T extends string> = _IdentifierParse<{ identifier: ''; rest: T }>\n\n// prettier-ignore\ntype _IdentifierParse<S extends { identifier: string, rest: string }> =\n  S extends { identifier: '', rest: `${infer Head extends IdentifierHead}${infer Tail}` } ?\n    _IdentifierParse<{ identifier: Head, rest: Tail }> :\n    S extends { identifier: string, rest: `${infer Head extends IdentifierTail}${infer Tail}`} ?\n      _IdentifierParse<{ identifier: `${S['identifier']}${Head}`, rest: Tail }> :\n      S\n", "import type { RequiredParams, OptionalParams } from './params.ts'\nimport { parse } from './parse.ts'\nimport type { ParseResult } from './parse.ts'\nimport type { Token } from './parse.ts'\nimport type { RoutePattern } from './route-pattern.ts'\nimport type { Variant } from './variant.ts'\n\nexport class MissingParamError extends Error {\n  readonly paramName: string\n\n  constructor(paramName: string) {\n    super(`Missing required parameter: ${paramName}`)\n    this.name = 'MissingParamError'\n    this.paramName = paramName\n  }\n}\n\nexport function createHrefBuilder<T extends string | RoutePattern = string>(): HrefBuilder<T> {\n  return (pattern: string | RoutePattern, ...args: any) =>\n    formatHref(parse(typeof pattern === 'string' ? pattern : pattern.source), ...args)\n}\n\nexport function formatHref(\n  parsed: ParseResult,\n  params?: Record<string, any>,\n  searchParams?: Record<string, any>,\n): string {\n  params = params ?? {}\n\n  let href = ''\n\n  if (parsed.hostname != null) {\n    // Default protocol is https because it's free these days so there's no\n    // excuse not to use it.\n    let protocol = parsed.protocol != null ? resolveTokens(parsed.protocol, '', params) : 'https'\n    let hostname = resolveTokens(parsed.hostname, '.', params)\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    href += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = resolveTokens(parsed.pathname, '/', params)\n    href += pathname.startsWith('/') ? pathname : `/${pathname}`\n  } else {\n    href += '/'\n  }\n\n  if (searchParams) {\n    href += `?${new URLSearchParams(searchParams)}`\n  } else if (parsed.search) {\n    href += `?${parsed.search}`\n  }\n\n  return href\n}\n\nfunction resolveTokens(tokens: Token[], sep: string, params: Record<string, any>): string {\n  let str = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable' || token.type === 'wildcard') {\n      let name = token.name ?? '*'\n      if (params[name] == null) throw new MissingParamError(name)\n      str += String(params[name])\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      try {\n        str += resolveTokens(token.tokens, sep, params)\n      } catch (error) {\n        if (!(error instanceof MissingParamError)) {\n          throw error\n        }\n\n        // Missing required parameter, ok to skip since it's optional\n      }\n    }\n  }\n\n  return str\n}\n\nexport interface HrefBuilder<T extends string | RoutePattern = string> {\n  <P extends string extends T ? string : SourceOf<T> | Variant<SourceOf<T>>>(\n    pattern: P | RoutePattern<P>,\n    ...args: HrefBuilderArgs<P>\n  ): string\n}\n\n// prettier-ignore\ntype SourceOf<T> =\n  T extends string ? T :\n  T extends RoutePattern<infer S extends string> ? S :\n  never\n\n// prettier-ignore\nexport type HrefBuilderArgs<T extends string> =\n  [RequiredParams<T>] extends [never] ?\n    [] | [null | undefined | Record<string, any>] | [null | undefined | Record<string, any>, HrefSearchParams] :\n    [HrefParams<T>, HrefSearchParams] | [HrefParams<T>]\n\n// prettier-ignore\ntype HrefParams<T extends string> =\n  Record<RequiredParams<T>, ParamValue> &\n  Partial<Record<OptionalParams<T>, ParamValue | null | undefined>>\n\ntype HrefSearchParams =\n  | NonNullable<ConstructorParameters<typeof URLSearchParams>[0]>\n  | Record<string, ParamValue>\n\ntype ParamValue = string | number | bigint | boolean\n", "import type { Token, ParseResult, ParsedPattern } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport function stringify(parsed: Partial<ParseResult>): string {\n  let str = ''\n\n  if (parsed.hostname != null) {\n    let protocol = parsed.protocol != null ? stringifyTokens(parsed.protocol) : ''\n    let hostname = parsed.hostname != null ? stringifyTokens(parsed.hostname, '.') : ''\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    str += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = stringifyTokens(parsed.pathname, '/')\n    str += startsWithSeparator(parsed.pathname) ? pathname : `/${pathname}`\n  } else {\n    str += '/'\n  }\n\n  if (parsed.search) {\n    str += `?${parsed.search}`\n  } else if (parsed.searchConstraints != null) {\n    let search = stringifySearchConstraints(parsed.searchConstraints)\n    if (search !== '') {\n      str += `?${search}`\n    }\n  }\n\n  return str\n}\n\nexport function startsWithSeparator(tokens: Token[]): boolean {\n  if (tokens.length === 0) return false\n\n  let firstToken = tokens[0]\n  if (firstToken.type === 'separator') return true\n\n  // Check if it starts with an optional that contains a separator\n  if (firstToken.type === 'optional' && firstToken.tokens && firstToken.tokens.length > 0) {\n    return startsWithSeparator(firstToken.tokens)\n  }\n\n  return false\n}\n\nexport function stringifyTokens(tokens: Token[], sep = ''): string {\n  let str = ''\n\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i]\n    if (token.type === 'variable') {\n      str += `:${token.name}`\n    } else if (token.type === 'wildcard') {\n      str += `*${token.name ?? ''}`\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      str += `(${stringifyTokens(token.tokens, sep)})`\n    }\n  }\n\n  return str\n}\n\nexport function stringifySearchConstraints(search: SearchConstraints): string {\n  let parts: string[] = []\n\n  for (let [key, value] of search.entries()) {\n    if (value.allowBare && !value.requireAssignment) {\n      // Parameter can appear without assignment (e.g., just \"debug\")\n      parts.push(key)\n    } else if (value.requiredValues && value.requiredValues.size > 0) {\n      // Parameter has specific required values - create separate entries for each value\n      for (let requiredValue of value.requiredValues) {\n        parts.push(`${key}=${requiredValue}`)\n      }\n    } else if (value.requireAssignment) {\n      // Parameter requires assignment but no specific values\n      parts.push(`${key}=`)\n    }\n  }\n\n  return parts.join('&')\n}\n\n// prettier-ignore\nexport type Stringify<T extends ParsedPattern> =\n  T['hostname'] extends Token[] ?\n    `${StringifyTokens<T['protocol'], ''>}://${StringifyTokens<T['hostname'], '.'>}${StringifyPort<T['port']>}${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}` :\n    `${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}`\n\n// prettier-ignore\ntype StringifyTokens<T extends Token[] | undefined, Sep extends string> =\n  T extends undefined ? '' :\n  T extends [] ? '' :\n  T extends [infer Head extends Token, ...infer Tail extends Token[]] ?\n    `${StringifyToken<Head, Sep>}${StringifyTokens<Tail, Sep>}` :\n    never\n\n// prettier-ignore\ntype StringifyToken<T extends Token, Sep extends string> =\n  T extends { type: 'text', value: infer V extends string } ? V :\n  T extends { type: 'variable', name: infer N extends string } ? `:${N}` :\n  T extends { type: 'wildcard', name: infer N extends string } ? `*${N}` :\n  T extends { type: 'wildcard' } ? '*' :\n  T extends { type: 'separator' } ? Sep :\n  T extends { type: 'optional', tokens: infer Tokens extends Token[] } ? `(${StringifyTokens<Tokens, Sep>})` :\n  never\n\n// prettier-ignore\ntype StringifyPathname<T extends Token[] | undefined> =\n  T extends undefined ? '/' :\n  T extends [] ? '/' :\n  T extends Token[] ?\n    StartsWithSeparator<T> extends true ?\n      `${StringifyTokens<T, '/'>}` :\n      `/${StringifyTokens<T, '/'>}` :\n    never\n\ntype StringifyPort<T extends string | undefined> = T extends string ? `:${T}` : ''\n\ntype StringifySearch<T extends string | undefined> = T extends string ? `?${T}` : ''\n\n// prettier-ignore\nexport type StartsWithSeparator<T extends Token[]> =\n  T extends [] ? false :\n  T extends [{ type: 'separator' }, ...Token[]] ? true :\n  T extends [{ type: 'optional', tokens: infer Tokens extends Token[] }, ...Token[]] ?\n    StartsWithSeparator<Tokens> :\n    false\n", "import type { Parse, ParsedPattern, ParseResult, Separator, Token } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\nimport { stringify, startsWithSeparator } from './stringify.ts'\nimport type { Stringify, StartsWithSeparator } from './stringify.ts'\n\nexport function join(a: ParseResult, b: ParseResult): string {\n  let { protocol, hostname, port } = b.hostname != null ? b : a\n  let pathname = joinPathnames(a.pathname, b.pathname)\n  let searchConstraints = joinSearchConstraints(a.searchConstraints, b.searchConstraints)\n\n  return stringify({\n    protocol,\n    hostname,\n    port,\n    pathname,\n    searchConstraints,\n  })\n}\n\nfunction joinPathnames(a: Token[] | undefined, b: Token[] | undefined): Token[] | undefined {\n  if (b == null || b.length === 0) return a\n  if (a == null || a.length === 0) return b\n\n  let tokens = [...a]\n\n  // Remove trailing separator from base if present\n  if (tokens.length > 0 && tokens[tokens.length - 1].type === 'separator') {\n    tokens.pop()\n  }\n\n  // Check if input starts with a separator (including inside optionals)\n  let inputStartsWithSeparator = startsWithSeparator(b)\n\n  // If input is exactly a single separator, there is nothing to append.\n  // This avoids creating a trailing slash like \"/hello/\" when joining with base '/'.\n  if (b.length === 1 && b[0].type === 'separator') {\n    return tokens\n  }\n\n  // Only add separator between base and input if input doesn't start with one\n  if (!inputStartsWithSeparator) {\n    tokens.push({ type: 'separator' })\n  }\n\n  // Add input pathname\n  tokens.push(...b)\n\n  return tokens\n}\n\nfunction joinSearchConstraints(\n  baseSearch: SearchConstraints | undefined,\n  inputSearch: SearchConstraints | undefined,\n): SearchConstraints | undefined {\n  if (inputSearch == null) return baseSearch\n  if (baseSearch == null) return inputSearch\n\n  // Merge the two search constraint maps\n  let merged = new Map(baseSearch)\n\n  for (let [key, inputConstraint] of inputSearch.entries()) {\n    let baseConstraint = merged.get(key)\n    if (baseConstraint == null) {\n      merged.set(key, inputConstraint)\n    } else {\n      // Merge constraints for the same key\n      let mergedConstraint = {\n        requireAssignment: baseConstraint.requireAssignment || inputConstraint.requireAssignment,\n        allowBare: baseConstraint.allowBare && inputConstraint.allowBare,\n        requiredValues: undefined as Set<string> | undefined,\n      }\n\n      // Merge required values\n      if (baseConstraint.requiredValues || inputConstraint.requiredValues) {\n        mergedConstraint.requiredValues = new Set([\n          ...(baseConstraint.requiredValues || []),\n          ...(inputConstraint.requiredValues || []),\n        ])\n      }\n\n      merged.set(key, mergedConstraint)\n    }\n  }\n\n  return merged\n}\n\nexport type Join<A extends string, B extends string> = _Join<Parse<A>, Parse<B>>\n\ntype _Join<A extends ParsedPattern, B extends ParsedPattern> = Stringify<{\n  protocol: JoinOriginField<A, B, 'protocol'>\n  hostname: JoinOriginField<A, B, 'hostname'>\n  port: JoinOriginField<A, B, 'port'>\n  pathname: JoinPathnames<A['pathname'], B['pathname']>\n  search: JoinSearch<A['search'], B['search']>\n}>\n\n// prettier-ignore\ntype JoinOriginField<\n  A extends ParsedPattern,\n  B extends ParsedPattern,\n  Field extends 'protocol' | 'hostname' | 'port'\n> = B['hostname'] extends Token[] ? B[Field] : A[Field]\n\n// prettier-ignore\ntype JoinPathnames<A extends Token[] | undefined, B extends Token[] | undefined> =\n  B extends undefined ? A :\n  B extends [] ? A :\n  A extends undefined ? B :\n  A extends [] ? B :\n  A extends Token[] ?\n    B extends Token[] ? JoinPathnameTokens<RemoveTrailingSeparator<A>, B> :\n    never :\n  never\n\n// prettier-ignore\ntype RemoveTrailingSeparator<T extends Token[]> =\n  T extends [...infer Rest extends Token[], Separator] ? Rest : T\n\n// prettier-ignore\ntype JoinPathnameTokens<\n  A extends Token[],\n  B extends Token[]\n> = B extends [Separator] ?\n    A :\n    StartsWithSeparator<B> extends true ?\n      [...A, ...B] :\n      [...A, Separator, ...B]\n\n// prettier-ignore\ntype JoinSearch<\n  A extends string | undefined,\n  B extends string | undefined\n> = B extends undefined ? A :\n    A extends undefined ? B :\n    `${A}&${B}`\n", "import { formatHref } from './href.ts'\nimport type { HrefBuilderArgs } from './href.ts'\nimport { join } from './join.ts'\nimport type { Join } from './join.ts'\nimport type { Params } from './params.ts'\nimport { parse } from './parse.ts'\nimport type { Token, ParseResult } from './parse.ts'\nimport { parseSearch } from './search-constraints.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport interface RoutePatternOptions {\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  ignoreCase?: boolean\n}\n\n/**\n * A pattern for matching URLs.\n */\nexport class RoutePattern<T extends string = string> {\n  /**\n   * The source string that was used to create this pattern.\n   */\n  readonly source: T\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  readonly ignoreCase: boolean\n\n  #parsed: ParseResult\n  #compiled: CompileResult | undefined\n\n  constructor(source: T | RoutePattern<T>, options?: RoutePatternOptions) {\n    this.source = typeof source === 'string' ? source : source.source\n    this.ignoreCase = options?.ignoreCase === true\n    this.#parsed = parse(this.source)\n  }\n\n  /**\n   * Generate a href (URL) for this pattern.\n   *\n   * @param params The parameters to use in the href.\n   * @param searchParams The search parameters to use in the href.\n   * @returns The href\n   */\n  href(...args: HrefBuilderArgs<T>): string {\n    return formatHref(this.#parsed, ...(args as any))\n  }\n\n  /**\n   * Join this pattern with another pattern. This is useful when building a pattern\n   * relative to a base pattern.\n   *\n   * Note: The returned pattern will use the same options as this pattern.\n   *\n   * @param input The pattern to join with\n   * @returns The joined pattern\n   */\n  join<P extends string>(input: P | RoutePattern<P>): RoutePattern<Join<T, P>> {\n    let parsedInput = parse(typeof input === 'string' ? input : input.source)\n    return new RoutePattern(join(this.#parsed, parsedInput) as Join<T, P>, {\n      ignoreCase: this.ignoreCase,\n    })\n  }\n\n  /**\n   * Match a URL against this pattern.\n   *\n   * @param url The URL to match\n   * @returns The parameters if the URL matches this pattern, `null` otherwise\n   */\n  match(url: URL | string): RouteMatch<T> | null {\n    if (typeof url === 'string') url = new URL(url)\n\n    let { matchOrigin, matcher, paramNames } = this.#compile()\n\n    let pathname = this.ignoreCase ? url.pathname.toLowerCase() : url.pathname\n    let match = matcher.exec(matchOrigin ? `${url.origin}${pathname}` : pathname)\n    if (match === null) return null\n\n    // Map positional capture groups to parameter names in source order\n    let params = {} as any\n    for (let i = 0; i < paramNames.length; i++) {\n      let paramName = paramNames[i]\n      params[paramName] = match[i + 1]\n    }\n\n    if (\n      this.#parsed.searchConstraints != null &&\n      !matchSearch(url.search, this.#parsed.searchConstraints)\n    ) {\n      return null\n    }\n\n    return { url, params }\n  }\n\n  #compile(): CompileResult {\n    if (this.#compiled) return this.#compiled\n    this.#compiled = compilePattern(this.#parsed, this.ignoreCase)\n    return this.#compiled\n  }\n\n  /**\n   * Test if a URL matches this pattern.\n   *\n   * @param url The URL to test\n   * @returns `true` if the URL matches this pattern, `false` otherwise\n   */\n  test(url: URL | string): boolean {\n    return this.match(url) !== null\n  }\n\n  toString() {\n    return this.source\n  }\n}\n\nexport interface RouteMatch<T extends string> {\n  /**\n   * The parameters that were extracted from the URL protocol, hostname, and/or pathname.\n   */\n  readonly params: Params<T>\n  /**\n   * The URL that was matched.\n   */\n  readonly url: URL\n}\n\ninterface CompileResult {\n  matchOrigin: boolean\n  matcher: RegExp\n  paramNames: string[]\n}\n\nfunction compilePattern(parsed: ParseResult, ignoreCase: boolean): CompileResult {\n  let { protocol, hostname, port, pathname } = parsed\n\n  let matchOrigin = hostname !== undefined\n  let matcher: RegExp\n  let paramNames: string[] = []\n\n  if (matchOrigin) {\n    let protocolSource = protocol\n      ? tokensToRegExpSource(protocol, '', '.*', paramNames, true)\n      : '[^:]+'\n    let hostnameSource = hostname\n      ? tokensToRegExpSource(hostname, '.', '[^.]+?', paramNames, true)\n      : '[^/:]+'\n    let portSource = port !== undefined ? `:${regexpEscape(port)}` : '(?::[0-9]+)?'\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^${protocolSource}://${hostnameSource}${portSource}/${pathnameSource}$`)\n  } else {\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^/${pathnameSource}$`)\n  }\n\n  return { matchOrigin, matcher, paramNames }\n}\n\nfunction tokensToRegExpSource(\n  tokens: Token[],\n  sep: string,\n  paramRegExpSource: string,\n  paramNames: string[],\n  forceLowerCase: boolean,\n): string {\n  let source = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable') {\n      paramNames.push(token.name)\n      source += `(${paramRegExpSource})`\n    } else if (token.type === 'wildcard') {\n      if (token.name) {\n        paramNames.push(token.name)\n        source += `(.*)`\n      } else {\n        source += `(?:.*)`\n      }\n    } else if (token.type === 'text') {\n      source += regexpEscape(forceLowerCase ? token.value.toLowerCase() : token.value)\n    } else if (token.type === 'separator') {\n      source += regexpEscape(sep)\n    } else if (token.type === 'optional') {\n      source += `(?:${tokensToRegExpSource(token.tokens, sep, paramRegExpSource, paramNames, forceLowerCase)})?`\n    }\n  }\n\n  return source\n}\n\nfunction regexpEscape(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction matchSearch(search: string, constraints: SearchConstraints): boolean {\n  let { namesWithoutAssignment, namesWithAssignment, valuesByKey } = parseSearch(search)\n\n  for (let [key, constraint] of constraints) {\n    let hasAssigned = namesWithAssignment.has(key),\n      hasBare = namesWithoutAssignment.has(key),\n      values = valuesByKey.get(key)\n\n    if (constraint.requiredValues && constraint.requiredValues.size > 0) {\n      if (!values) return false\n      for (let value of constraint.requiredValues) {\n        if (!values.has(value)) return false\n      }\n      continue\n    }\n\n    if (constraint.requireAssignment) {\n      if (!hasAssigned) return false\n      continue\n    }\n\n    if (!(hasAssigned || hasBare)) return false\n  }\n\n  return true\n}\n", "import type { Matcher, MatchResult } from './matcher.ts'\nimport { RoutePattern } from './route-pattern.ts'\n\n/**\n * A simple array-based matcher that compiles route patterns to regular expressions.\n *\n * **Use RegExpMatcher when:**\n * - You have a single or handful of patterns\n * - Build time is critical (cold boot scenarios)\n * - Pattern set changes frequently (cheap to rebuild)\n * - Memory footprint needs to be minimal\n */\nexport class RegExpMatcher<T = any> implements Matcher<T> {\n  #pairs: { pattern: RoutePattern; data: T }[] = []\n  #count = 0\n\n  add<P extends string>(pattern: P | RoutePattern<P>, data: T): void {\n    let routePattern = typeof pattern === 'string' ? new RoutePattern(pattern) : pattern\n    this.#pairs.push({ pattern: routePattern, data })\n    this.#count++\n  }\n\n  match(url: string | URL): MatchResult<T> | null {\n    if (typeof url === 'string') url = new URL(url)\n\n    for (let { pattern, data } of this.#pairs) {\n      let match = pattern.match(url)\n      if (match) {\n        return { data, params: match.params, url: match.url }\n      }\n    }\n\n    return null\n  }\n\n  *matchAll(url: string | URL): Generator<MatchResult<T>> {\n    if (typeof url === 'string') url = new URL(url)\n\n    for (let { pattern, data } of this.#pairs) {\n      let match = pattern.match(url)\n      if (match) {\n        yield { data, params: match.params, url: match.url }\n      }\n    }\n  }\n\n  get size(): number {\n    return this.#count\n  }\n}\n", "import type { Matcher, MatchResult } from './matcher.ts'\nimport { parse } from './parse.ts'\nimport type { Token, ParseResult } from './parse.ts'\nimport { RoutePattern } from './route-pattern.ts'\nimport { parseSearch } from './search-constraints.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\nimport { stringifyTokens } from './stringify.ts'\n\ninterface TrieNode {\n  // Unique ID for deduplication\n  id?: number\n\n  // Exact literal segments (fast path)\n  staticChildren: Map<string, TrieNode>\n\n  // Parametric segment shapes with precompiled matchers\n  shapeChildren: Map<string, { node: TrieNode; tokens: Token[]; ignoreCase: boolean }>\n\n  // Fallback for unconstrained single-segment variables\n  variableChild?: VariableNode\n\n  // Wildcard edge that can consume 0..n segments and continue matching\n  wildcardEdge?: WildcardEdge\n\n  // Optional edges that can be taken or skipped\n  optionalEdges: OptionalEdge[]\n\n  // Terminal patterns that end at this node\n  patterns: PatternMatch<any>[]\n\n  // Depth metadata for wildcard pruning\n  minDepthToTerminal?: number\n  maxDepthToTerminal?: number\n\n  // Track if any patterns reachable from this node have ignoreCase\n  hasIgnoreCasePatterns?: boolean\n\n  // Parent node for incremental depth updates\n  parent?: TrieNode\n}\n\ninterface VariableNode extends TrieNode {\n  paramName: string\n}\n\ninterface WildcardEdge {\n  paramName?: string // undefined for unnamed wildcards\n  continuation: TrieNode\n}\n\ninterface OptionalEdge {\n  // Where to continue after the optional (for both take and skip paths)\n  continuation: TrieNode\n}\n\ninterface PatternMatch<T = any> {\n  pattern: RoutePattern\n  node: T\n  paramNames: string[]\n  matchOrigin: boolean\n  // Search constraints applied after structural match\n  searchConstraints?: SearchConstraints\n  // Precomputed specificity for deterministic ranking\n  specificity: number\n  // Case sensitivity for pathname matching\n  ignoreCase: boolean\n}\n\n// Origin trie for full URL patterns\ninterface OriginTrieNode {\n  // Static protocol patterns (case-insensitive)\n  protocolChildren: Map<string, ProtocolNode>\n  // Variable protocol patterns\n  protocolVariableChild?: { paramName: string; node: ProtocolNode }\n  // Catch-all for any protocol (no protocol specified in pattern)\n  anyProtocolChild?: ProtocolNode\n}\n\ninterface ProtocolNode {\n  // Hostname trie (reversed labels, case-insensitive)\n  hostnameRoot: HostnameTrieNode\n}\n\ninterface HostnameTrieNode {\n  // Literal hostname labels (reversed: com -> example -> api)\n  staticChildren: Map<string, HostnameTrieNode>\n  // Variable hostname labels\n  variableChild?: { paramName: string; node: HostnameTrieNode }\n  // Wildcard hostname labels\n  wildcardChild?: { paramName?: string; node: HostnameTrieNode }\n  // Port-specific pathname tries\n  portChildren: Map<string, TrieNode>\n  // Default pathname trie (any port)\n  defaultPathnameTrie?: TrieNode\n\n  // Parent node for incremental depth updates\n  parent?: HostnameTrieNode\n}\n\ninterface MatchState {\n  segments: string[]\n  segmentIndex: number\n  params: Record<string, string>\n  specificity: number\n  // For deduplication in best-first traversal\n  nodeId?: number\n  wildcardSpan?: string // e.g., \"3-5\" for wildcard consuming segments 3 to 5\n}\n\n// Priority queue item for best-first traversal\ninterface TraversalState {\n  node: TrieNode\n  state: MatchState\n  // Priority based on combined specificity + estimated remaining depth\n  priority: number\n}\n\n// Add interface ParsedURL {\ninterface ParsedURL {\n  protocol: string\n  hostname: string\n  hostnameLabels: string[]\n  port: string | undefined\n  pathname: string\n  segments: string[]\n  search: string\n  searchParsed: ReturnType<typeof parseSearch>\n}\n\nexport interface TrieMatcherOptions {\n  /**\n   * The maximum number of traversal states to explore during matching.\n   *\n   * This prevents excessive computation in cases with high branching (e.g., many optionals or wildcards).\n   * Increase for more complex routes if you encounter truncated results.\n   *\n   * Default is 10_000.\n   */\n  maxTraversalStates?: number\n  /**\n   * The maximum depth of nested optionals to explore in traversal.\n   *\n   * Limits branching in patterns like /api(/v1(/v2(/v3))) to prevent exponential state growth.\n   * Adjust higher for apps with deeply nested optionals; default 5 covers most cases without performance hit.\n   *\n   * Default is 5.\n   */\n  maxOptionalDepth?: number\n}\n\n/**\n * A trie-based matcher optimized for large route sets with repeated matching.\n *\n * **Use TrieMatcher when:**\n * - You have 100+ route patterns\n * - Patterns are registered once and matched repeatedly (e.g., web server routing)\n * - Match performance matters more than build time\n * - You need exhaustive matching via `matchAll()`\n */\nexport class TrieMatcher<T = any> implements Matcher<T> {\n  #pathnameOnlyRoot: TrieNode\n  #originRoot: OriginTrieNode\n  #patternCount = 0\n  #maxTraversalStates: number\n  #nodeIdCounter = 0\n  #maxOptionalDepth = 5\n\n  constructor(options?: TrieMatcherOptions) {\n    this.#pathnameOnlyRoot = this.#createNode()\n    this.#originRoot = this.#createOriginNode()\n    this.#maxTraversalStates = options?.maxTraversalStates ?? 10_000\n    this.#maxOptionalDepth = options?.maxOptionalDepth ?? 5\n  }\n\n  /**\n   * Add a pattern to the trie\n   */\n  add(pattern: string | RoutePattern, node: T): void {\n    let routePattern = typeof pattern === 'string' ? new RoutePattern(pattern) : pattern\n    let parsed = parse(routePattern.source)\n\n    // Enforce maxOptionalDepth across all token groups in this pattern\n    let maxDepthInPattern = 0\n    if (parsed.protocol)\n      maxDepthInPattern = Math.max(\n        maxDepthInPattern,\n        this.#maxOptionalDepthInTokens(parsed.protocol),\n      )\n    if (parsed.hostname)\n      maxDepthInPattern = Math.max(\n        maxDepthInPattern,\n        this.#maxOptionalDepthInTokens(parsed.hostname),\n      )\n    if (parsed.pathname)\n      maxDepthInPattern = Math.max(\n        maxDepthInPattern,\n        this.#maxOptionalDepthInTokens(parsed.pathname),\n      )\n    if (maxDepthInPattern > this.#maxOptionalDepth) {\n      throw new Error(\n        `Pattern exceeds maxOptionalDepth (${this.#maxOptionalDepth}): ${routePattern.source}`,\n      )\n    }\n\n    let isOrigin = parsed.protocol || parsed.hostname || parsed.port\n    if (isOrigin) {\n      // Build origin structure\n      // Handle protocol\n      if (parsed.protocol) {\n        if (parsed.protocol.length === 1 && parsed.protocol[0].type === 'variable') {\n          // Variable protocol pattern\n          if (!this.#originRoot.protocolVariableChild) {\n            this.#originRoot.protocolVariableChild = {\n              paramName: parsed.protocol[0].name,\n              node: { hostnameRoot: this.#createHostnameNode() },\n            }\n          }\n          this.#addHostnamePattern(\n            this.#originRoot.protocolVariableChild.node.hostnameRoot,\n            parsed.hostname || [],\n            parsed.port,\n            parsed.pathname,\n            routePattern,\n            node,\n            parsed.searchConstraints,\n            parsed,\n          )\n        } else {\n          let protocolVariants = this.#expandProtocolOptionals(parsed.protocol)\n\n          for (let protocolKey of protocolVariants) {\n            let existing = this.#originRoot.protocolChildren.get(protocolKey)\n            if (!existing) {\n              existing = { hostnameRoot: this.#createHostnameNode() }\n              this.#originRoot.protocolChildren.set(protocolKey, existing)\n            }\n            this.#addHostnamePattern(\n              existing.hostnameRoot,\n              parsed.hostname || [],\n              parsed.port,\n              parsed.pathname,\n              routePattern,\n              node,\n              parsed.searchConstraints,\n              parsed,\n            )\n          }\n        }\n      } else {\n        // Any protocol pattern (no protocol specified)\n        if (!this.#originRoot.anyProtocolChild) {\n          this.#originRoot.anyProtocolChild = { hostnameRoot: this.#createHostnameNode() }\n        }\n        this.#addHostnamePattern(\n          this.#originRoot.anyProtocolChild.hostnameRoot,\n          parsed.hostname || [],\n          parsed.port,\n          parsed.pathname,\n          routePattern,\n          node,\n          parsed.searchConstraints,\n          parsed,\n        )\n      }\n    } else {\n      let root = this.#pathnameOnlyRoot\n      if (!parsed.pathname) {\n        // Empty pattern matches root\n        this.#addPatternMatch(root, routePattern, node, [], false, parsed.searchConstraints, parsed)\n        this.#updateDepthUp(root)\n        this.#patternCount++\n        return\n      }\n\n      this.#buildPathTrie(\n        root,\n        parsed.pathname,\n        routePattern,\n        node,\n        parsed.searchConstraints,\n        parsed,\n      )\n    }\n\n    this.#patternCount++\n  }\n\n  /**\n   * Find the best match for a URL\n   */\n  match(url: string | URL): MatchResult<T> | null {\n    let urlObj = typeof url === 'string' ? new URL(url) : url\n\n    let parsedUrl: ParsedURL = {\n      protocol: urlObj.protocol.slice(0, -1).toLowerCase(),\n      hostname: urlObj.hostname.toLowerCase(),\n      hostnameLabels: urlObj.hostname.toLowerCase().split('.').reverse(),\n      port: urlObj.port,\n      pathname: urlObj.pathname.replace(/^\\/+/, '').replace(/\\/+$/, ''),\n      segments: urlObj.pathname\n        .replace(/^\\/+/, '')\n        .replace(/\\/+$/, '')\n        .split('/')\n        .filter((s) => s !== ''),\n      search: urlObj.search,\n      searchParsed: parseSearch(urlObj.search),\n    }\n\n    let segments = parsedUrl.segments\n\n    let originMatch = null\n    if (parsedUrl.protocol || parsedUrl.hostname || parsedUrl.port) {\n      originMatch = this.#tryOriginMatch(parsedUrl, segments, urlObj)\n      if (originMatch) return originMatch\n    }\n\n    let staticMatch = this.#tryStaticPathMatch(segments, urlObj.search, urlObj)\n    if (staticMatch) return staticMatch\n\n    let pathnameMatches = this.#findPathnameMatches(segments, urlObj.search, true)\n    if (pathnameMatches.length > 0) {\n      let best = pathnameMatches[0]\n      return { data: best.match.node, params: best.state.params, url: urlObj }\n    }\n\n    return null\n  }\n\n  /**\n   * Find all matches for a URL\n   */\n  *matchAll(url: string | URL): Generator<MatchResult<T>> {\n    let urlObj = typeof url === 'string' ? new URL(url) : url\n    let pathname = urlObj.pathname\n\n    // Normalize pathname - remove leading and trailing slashes\n    if (pathname.startsWith('/')) {\n      pathname = pathname.slice(1)\n    }\n    if (pathname.endsWith('/') && pathname.length > 0) {\n      pathname = pathname.slice(0, -1)\n    }\n\n    let segments = pathname === '' ? [] : pathname.split('/').filter((s) => s !== '')\n\n    // Combine origin and pathname matches (no early exit for matchAll)\n    let allMatches: Array<{ match: PatternMatch<any>; state: MatchState }> = []\n\n    // Add origin matches (higher priority) - no early exit\n    allMatches.push(...this.#findOriginMatches(urlObj, segments, urlObj.search, false))\n\n    let staticAll = this.#tryStaticPathAll(segments, urlObj.search, urlObj)\n    allMatches.push(...staticAll)\n\n    // Add pathname matches (lower priority) - no early exit\n    allMatches.push(...this.#findPathnameMatches(segments, urlObj.search, false))\n\n    // Already filtered by inline search checks, just sort\n    allMatches.sort(\n      (a, b) => this.#finalScore(b.match, b.state) - this.#finalScore(a.match, a.state),\n    )\n\n    for (let match of allMatches) {\n      yield {\n        data: match.match.node,\n        params: match.state.params,\n        url: urlObj,\n      }\n    }\n  }\n\n  /**\n   * Number of patterns in the trie\n   */\n  get size(): number {\n    return this.#patternCount\n  }\n\n  // Private implementation methods\n\n  #finalScore(match: PatternMatch<any>, state: MatchState): number {\n    return match.specificity + state.specificity\n  }\n\n  #updateDepthUp(node: TrieNode): void {\n    let minD = node.patterns.length > 0 ? 0 : Infinity\n    let maxD = node.patterns.length > 0 ? 0 : 0\n\n    let updateDepth = (child: TrieNode, minIncrement: number, maxIncrement: number) => {\n      let childDMin = child.minDepthToTerminal ?? Infinity\n      let childDMax = child.maxDepthToTerminal ?? 0\n      minD = Math.min(minD, childDMin + minIncrement)\n      maxD = Math.max(maxD, childDMax + maxIncrement)\n    }\n\n    // Static, shape, and variable children all increment depth by 1\n    for (let child of node.staticChildren.values()) updateDepth(child, 1, 1)\n    for (let entry of node.shapeChildren.values()) updateDepth(entry.node, 1, 1)\n    if (node.variableChild) updateDepth(node.variableChild, 1, 1)\n\n    // Wildcard and optional edges don't increment min depth\n    if (node.wildcardEdge) updateDepth(node.wildcardEdge.continuation, 0, 100)\n    for (let opt of node.optionalEdges) updateDepth(opt.continuation, 0, 0)\n\n    node.minDepthToTerminal = minD === Infinity ? undefined : minD\n    node.maxDepthToTerminal = maxD\n\n    if (node.parent) this.#updateDepthUp(node.parent)\n  }\n\n  #createNode(): TrieNode {\n    let node: any = {\n      staticChildren: new Map(),\n      shapeChildren: new Map(),\n      optionalEdges: [],\n      patterns: [],\n      minDepthToTerminal: undefined,\n      maxDepthToTerminal: undefined,\n      parent: undefined,\n    }\n    // Assign unique ID for deduplication\n    node.id = this.#nodeIdCounter++\n    return node\n  }\n\n  #createOriginNode(): OriginTrieNode {\n    return {\n      protocolChildren: new Map(),\n    }\n  }\n\n  #createHostnameNode(): HostnameTrieNode {\n    return {\n      staticChildren: new Map(),\n      portChildren: new Map(),\n    }\n  }\n\n  #expandProtocolOptionals(protocolTokens: Token[]): string[] {\n    // Handle simple \"text + optional(text)\" pattern like http(s):// -> [\"http\", \"https\"]\n    if (\n      protocolTokens.length !== 2 ||\n      protocolTokens[0].type !== 'text' ||\n      protocolTokens[1].type !== 'optional'\n    ) {\n      return [stringifyTokens(protocolTokens).toLowerCase()]\n    }\n\n    let baseText = protocolTokens[0].value\n    let optionalToken = protocolTokens[1] as { type: 'optional'; tokens: Token[] }\n\n    if (optionalToken.tokens.length !== 1 || optionalToken.tokens[0].type !== 'text') {\n      return [stringifyTokens(protocolTokens).toLowerCase()]\n    }\n\n    let optionalText = optionalToken.tokens[0].value\n    return [baseText.toLowerCase(), (baseText + optionalText).toLowerCase()]\n  }\n\n  #addHostnamePattern(\n    hostnameNode: HostnameTrieNode,\n    hostnameTokens: Token[],\n    port: string | undefined,\n    pathnameTokens: Token[] | undefined,\n    pattern: RoutePattern,\n    userNode: T,\n    searchConstraints?: SearchConstraints,\n    parsed?: ParseResult,\n  ): void {\n    // Reverse hostname labels for trie traversal (com.example.api -> api.example.com)\n    let reversedLabels = this.#reverseHostnameLabels(hostnameTokens)\n    let finalHostnameNode = this.#traverseHostnameLabels(hostnameNode, reversedLabels)\n\n    // Get or create pathname trie for this hostname+port combination\n    let pathnameTrie: TrieNode\n    if (port !== undefined) {\n      let existing = finalHostnameNode.portChildren.get(port)\n      if (!existing) {\n        existing = this.#createNode()\n        finalHostnameNode.portChildren.set(port, existing)\n      }\n      pathnameTrie = existing\n    } else {\n      if (!finalHostnameNode.defaultPathnameTrie) {\n        finalHostnameNode.defaultPathnameTrie = this.#createNode()\n      }\n      pathnameTrie = finalHostnameNode.defaultPathnameTrie\n    }\n\n    // Add pathname pattern to the trie\n    if (pathnameTokens) {\n      this.#buildPathTrie(\n        pathnameTrie,\n        pathnameTokens,\n        pattern,\n        userNode,\n        searchConstraints,\n        parsed,\n      )\n      this.#updateDepthUp(pathnameTrie)\n    } else {\n      this.#addPatternMatch(pathnameTrie, pattern, userNode, [], true, searchConstraints, parsed)\n      this.#updateDepthUp(pathnameTrie)\n    }\n  }\n\n  #reverseHostnameLabels(hostnameTokens: Token[]): Token[][] {\n    // Group hostname tokens by separators, then reverse the order\n    let labels = this.#groupTokensIntoSegments(hostnameTokens)\n    return labels.reverse()\n  }\n\n  #traverseHostnameLabels(startNode: HostnameTrieNode, labels: Token[][]): HostnameTrieNode {\n    let currentNode = startNode\n\n    for (let label of labels) {\n      if (label.length === 1 && label[0].type === 'text') {\n        // Static label\n        let labelText = label[0].value.toLowerCase()\n        let child = currentNode.staticChildren.get(labelText)\n        if (!child) {\n          child = this.#createHostnameNode()\n          currentNode.staticChildren.set(labelText, child)\n          child.parent = currentNode\n        }\n        currentNode = child\n      } else if (label.length === 1 && label[0].type === 'variable') {\n        // Variable label\n        if (!currentNode.variableChild) {\n          let childNode = this.#createHostnameNode()\n          childNode.parent = currentNode\n          currentNode.variableChild = {\n            paramName: label[0].name,\n            node: childNode,\n          }\n        }\n        currentNode = currentNode.variableChild.node\n      } else if (label.length === 1 && label[0].type === 'wildcard') {\n        // Wildcard label\n        if (!currentNode.wildcardChild) {\n          currentNode.wildcardChild = {\n            paramName: label[0].name,\n            node: this.#createHostnameNode(),\n          }\n          currentNode.wildcardChild.node.parent = currentNode\n        }\n        currentNode = currentNode.wildcardChild.node\n      } else {\n        // Complex hostname label, simplify and treat as variable\n        if (!currentNode.variableChild) {\n          currentNode.variableChild = {\n            paramName: 'hostname_segment',\n            node: this.#createHostnameNode(),\n          }\n          currentNode.variableChild.node.parent = currentNode\n        }\n        currentNode = currentNode.variableChild.node\n      }\n    }\n\n    return currentNode\n  }\n\n  #buildPathTrie(\n    node: TrieNode,\n    tokens: Token[],\n    pattern: RoutePattern,\n    userNode: T,\n    searchConstraints?: SearchConstraints,\n    parsed?: ParseResult,\n  ): void {\n    this.#buildTokenPath(node, tokens, pattern, (finalNode) => {\n      this.#addPatternMatch(finalNode, pattern, userNode, [], false, searchConstraints, parsed)\n      this.#updateDepthUp(finalNode)\n    })\n  }\n\n  #buildTokenPath(\n    node: TrieNode,\n    tokens: Token[],\n    pattern: RoutePattern,\n    onComplete: (node: TrieNode) => void,\n  ): void {\n    if (tokens.length === 0) {\n      onComplete(node)\n      return\n    }\n\n    // Check for inter-segment optional\n    let optionalIdx = this.#findInterSegmentOptional(tokens)\n\n    if (optionalIdx !== -1) {\n      // Handle inter-segment optional with convergence\n      let [before, opt, after] = [\n        tokens.slice(0, optionalIdx),\n        tokens[optionalIdx] as { type: 'optional'; tokens: Token[] },\n        tokens.slice(optionalIdx + 1),\n      ]\n\n      let branchNode = before.length > 0 ? this.#walkTokens(node, before, pattern) : node\n      let continuation = this.#createNode()\n      continuation.parent = branchNode\n\n      // Skip path\n      branchNode.optionalEdges.push({ continuation })\n\n      // Take path (routes to same continuation)\n      if (opt.tokens.length > 0) {\n        this.#buildTokenPath(branchNode, opt.tokens, pattern, (endNode) => {\n          endNode.optionalEdges.push({ continuation })\n        })\n      }\n\n      // Build suffix from shared continuation\n      this.#buildTokenPath(continuation, after, pattern, onComplete)\n      return\n    }\n\n    // Check for intra-segment optional and expand\n    if (this.#hasIntraSegmentOptionals(tokens)) {\n      for (let expanded of this.#expandIntraSegmentOptionals(tokens)) {\n        let finalNode = this.#walkTokens(node, expanded, pattern)\n        onComplete(finalNode)\n      }\n      return\n    }\n\n    // No optionals - simple walk\n    let finalNode = this.#walkTokens(node, tokens, pattern)\n    onComplete(finalNode)\n  }\n\n  #maxOptionalDepthInTokens(tokens: Token[]): number {\n    let maxDepth = 0\n    for (let token of tokens) {\n      if (token.type === 'optional') {\n        // Depth includes this optional + max depth of its children\n        let childDepth = this.#maxOptionalDepthInTokens(token.tokens)\n        maxDepth = Math.max(maxDepth, 1 + childDepth)\n      }\n    }\n    return maxDepth\n  }\n\n  #walkTokens(node: TrieNode, tokens: Token[], pattern: RoutePattern): TrieNode {\n    let current = node\n    let segments = this.#groupTokensIntoSegments(tokens)\n\n    for (let segment of segments) {\n      current = this.#walkSegment(current, segment, pattern)\n    }\n\n    return current\n  }\n\n  #walkSegment(node: TrieNode, segment: Token[], pattern: RoutePattern): TrieNode {\n    if (segment.length === 0) return node\n\n    // Single-token segment\n    if (segment.length === 1) {\n      let token = segment[0]\n\n      if (token.type === 'text') {\n        let key = pattern.ignoreCase ? token.value.toLowerCase() : token.value\n        let child = node.staticChildren.get(key) ?? this.#createNode()\n        if (!node.staticChildren.has(key)) {\n          node.staticChildren.set(key, child)\n          child.parent = node\n          if (pattern.ignoreCase) {\n            node.hasIgnoreCasePatterns = true\n            child.hasIgnoreCasePatterns = true\n          }\n        }\n        return child\n      }\n\n      if (token.type === 'variable') {\n        if (!node.variableChild) {\n          node.variableChild = { ...this.#createNode(), paramName: token.name }\n          node.variableChild.parent = node\n        }\n        return node.variableChild\n      }\n\n      if (token.type === 'wildcard') {\n        if (!node.wildcardEdge) {\n          let continuation = this.#createNode()\n          continuation.parent = node\n          node.wildcardEdge = { paramName: token.name, continuation }\n        }\n        return node.wildcardEdge.continuation\n      }\n\n      throw new Error(`Unexpected token type: ${token.type}`)\n    }\n\n    // Multi-token segment (shape)\n    if (segment.length > 1) {\n      let shapeKey = this.#getSimpleShapeKey(segment, pattern.ignoreCase)\n      let shapeEntry = node.shapeChildren.get(shapeKey)\n      if (!shapeEntry) {\n        let child = this.#createNode()\n        child.parent = node\n        shapeEntry = { node: child, tokens: segment, ignoreCase: pattern.ignoreCase }\n        node.shapeChildren.set(shapeKey, shapeEntry)\n        if (pattern.ignoreCase) {\n          node.hasIgnoreCasePatterns = true\n          shapeEntry.node.hasIgnoreCasePatterns = true\n        }\n      }\n      return shapeEntry.node\n    }\n\n    return node\n  }\n\n  #findInterSegmentOptional(tokens: Token[]): number {\n    // Find the first optional that contains a path separator (spans segments)\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i]\n      if (token.type === 'optional') {\n        // Check if this optional contains a path separator\n        let hasPathSeparator = token.tokens.some(\n          (t) => t.type === 'separator' && (tokens[i - 1]?.type !== 'separator' || i === 0),\n        )\n        if (hasPathSeparator) {\n          return i\n        }\n      }\n    }\n    return -1\n  }\n\n  #hasIntraSegmentOptionals(tokens: Token[]): boolean {\n    return tokens.some((t) => t.type === 'optional')\n  }\n\n  #expandIntraSegmentOptionals(tokens: Token[]): Token[][] {\n    // Simple recursive expansion for intra-segment optionals\n    let optionalIndex = tokens.findIndex((t) => t.type === 'optional')\n\n    if (optionalIndex === -1) {\n      return [tokens]\n    }\n\n    let beforeOptional = tokens.slice(0, optionalIndex)\n    let optionalToken = tokens[optionalIndex] as { type: 'optional'; tokens: Token[] }\n    let afterOptional = tokens.slice(optionalIndex + 1)\n\n    let optionalExpansions = this.#expandIntraSegmentOptionals(optionalToken.tokens)\n    let remainingExpansions = this.#expandIntraSegmentOptionals(afterOptional)\n\n    let result: Token[][] = []\n\n    // Skip optional\n    for (let remaining of remainingExpansions) {\n      result.push([...beforeOptional, ...remaining])\n    }\n\n    // Include optional\n    for (let optionalExpansion of optionalExpansions) {\n      for (let remaining of remainingExpansions) {\n        result.push([...beforeOptional, ...optionalExpansion, ...remaining])\n      }\n    }\n\n    return result\n  }\n\n  #groupTokensIntoSegments(tokens: Token[]): Token[][] {\n    let segments: Token[][] = []\n    let currentSegment: Token[] = []\n\n    for (let token of tokens) {\n      if (token.type === 'separator') {\n        if (currentSegment.length > 0) {\n          segments.push(currentSegment)\n          currentSegment = []\n        }\n      } else {\n        currentSegment.push(token)\n      }\n    }\n\n    if (currentSegment.length > 0) {\n      segments.push(currentSegment)\n    }\n\n    return segments\n  }\n\n  #getSimpleShapeKey(tokens: Token[], ignoreCase: boolean): string {\n    return tokens\n      .map((t) => {\n        if (t.type === 'text') return `L:${ignoreCase ? t.value.toLowerCase() : t.value}`\n        if (t.type === 'variable') return `V:${t.name}`\n        if (t.type === 'wildcard') return `W:${t.name || ''}`\n        return t.type\n      })\n      .join(',')\n  }\n\n  #addPatternMatch(\n    node: TrieNode,\n    pattern: RoutePattern,\n    userNode: T,\n    paramNames: string[],\n    matchOrigin: boolean,\n    searchConstraints?: SearchConstraints,\n    parsed?: ParseResult,\n  ): void {\n    // Check if this pattern is already added to this node\n    let existingPattern = node.patterns.find((p) => p.pattern.source === pattern.source)\n    if (existingPattern) {\n      return // Don't add duplicates\n    }\n\n    let specificity = this.#calculateSpecificity(parsed, searchConstraints)\n\n    node.patterns.push({\n      pattern,\n      node: userNode,\n      paramNames,\n      matchOrigin,\n      searchConstraints,\n      specificity,\n      ignoreCase: pattern.ignoreCase,\n    })\n\n    // Keep patterns sorted by specificity (highest first)\n    node.patterns.sort((a, b) => b.specificity - a.specificity)\n\n    this.#updateDepthUp(node)\n  }\n\n  #calculateSpecificity(\n    parsed: ParseResult | undefined,\n    searchConstraints?: SearchConstraints,\n  ): number {\n    let specificity = 0\n\n    if (!parsed) {\n      return specificity\n    }\n\n    // Origin patterns get higher base specificity\n    if (parsed.protocol || parsed.hostname || parsed.port) {\n      specificity += 10000\n    }\n\n    // Search constraints add specificity\n    if (searchConstraints && searchConstraints.size > 0) {\n      specificity += 1000\n    }\n\n    if (parsed.pathname) {\n      for (let token of parsed.pathname) {\n        if (token.type === 'text') {\n          specificity += 100 // Static segments are most specific\n        } else if (token.type === 'variable') {\n          specificity += 10 // Variables are less specific\n        } else if (token.type === 'wildcard') {\n          specificity += 1 // Wildcards are least specific\n        } else if (token.type === 'optional') {\n          // Optionals reduce specificity slightly\n          specificity -= 1\n        }\n      }\n    }\n\n    return specificity\n  }\n\n  #matchShape(\n    shapeEntry: { node: TrieNode; tokens: Token[]; ignoreCase: boolean },\n    segment: string,\n  ): { params: Record<string, string>; specificity: number } | null {\n    let normalizedSegment = shapeEntry.ignoreCase ? segment.toLowerCase() : segment\n    let pos = 0\n    let params: Record<string, string> = {}\n    let spec = 0\n\n    for (let i = 0; i < shapeEntry.tokens.length; i++) {\n      let token = shapeEntry.tokens[i]\n      if (token.type === 'text') {\n        let lit = shapeEntry.ignoreCase ? token.value.toLowerCase() : token.value\n        if (!normalizedSegment.startsWith(lit, pos)) return null\n        pos += lit.length\n        spec += 100\n      } else if (token.type === 'variable') {\n        let start = pos\n        let nextLit = ''\n        for (let j = i + 1; j < shapeEntry.tokens.length; j++) {\n          let nextToken = shapeEntry.tokens[j]\n          if (nextToken.type === 'text') {\n            nextLit = shapeEntry.ignoreCase ? nextToken.value.toLowerCase() : nextToken.value\n            break\n          }\n        }\n        let end = nextLit ? normalizedSegment.indexOf(nextLit, pos) : normalizedSegment.length\n        if (end === -1 && nextLit) return null\n        let value = segment.slice(start, end !== -1 ? end : undefined)\n        params[token.name] = value\n        pos = end !== -1 ? end : pos\n        spec += 10\n      } else if (token.type === 'wildcard') {\n        let value = segment.slice(pos)\n        if (token.name) params[token.name] = value\n        pos = segment.length\n        spec += 1\n      }\n    }\n    if (pos !== normalizedSegment.length) return null\n    return { params, specificity: spec }\n  }\n\n  #findOriginMatches(\n    url: URL,\n    segments: string[],\n    urlSearch: string | undefined,\n    earlyExit: boolean,\n  ): Array<{ match: PatternMatch<any>; state: MatchState }> {\n    let results: Array<{ match: PatternMatch<any>; state: MatchState }> = []\n\n    let protocol = url.protocol.slice(0, -1).toLowerCase() // Remove trailing ':'\n\n    // Try specific protocol patterns\n    let protocolNode = this.#originRoot.protocolChildren.get(protocol)\n    if (protocolNode) {\n      this.#matchHostnameAndPathname(protocolNode, url, segments, results, {}, urlSearch, earlyExit)\n      if (earlyExit && results.length > 0) return results\n    }\n\n    // Try variable protocol patterns\n    if (this.#originRoot.protocolVariableChild) {\n      let protocolParams = { [this.#originRoot.protocolVariableChild.paramName]: protocol }\n      this.#matchHostnameAndPathname(\n        this.#originRoot.protocolVariableChild.node,\n        url,\n        segments,\n        results,\n        protocolParams,\n        urlSearch,\n        earlyExit,\n      )\n      if (earlyExit && results.length > 0) return results\n    }\n\n    // Try any-protocol patterns\n    if (this.#originRoot.anyProtocolChild) {\n      this.#matchHostnameAndPathname(\n        this.#originRoot.anyProtocolChild,\n        url,\n        segments,\n        results,\n        {},\n        urlSearch,\n        earlyExit,\n      )\n      if (earlyExit && results.length > 0) return results\n    }\n\n    // Sort only for matchAll (when !earlyExit)\n    if (!earlyExit) {\n      results.sort(\n        (a, b) => this.#finalScore(b.match, b.state) - this.#finalScore(a.match, a.state),\n      )\n    }\n\n    return results\n  }\n\n  #findPathnameMatches(\n    segments: string[],\n    urlSearch: string | undefined,\n    earlyExit: boolean,\n  ): Array<{ match: PatternMatch<any>; state: MatchState }> {\n    let initialState: MatchState = {\n      segments,\n      segmentIndex: 0,\n      params: {},\n      specificity: 0,\n      nodeId: this.#pathnameOnlyRoot.id,\n    }\n\n    return this.#bestFirstTraversal(this.#pathnameOnlyRoot, initialState, earlyExit, urlSearch)\n  }\n\n  #matchHostnameAndPathname(\n    protocolNode: ProtocolNode,\n    url: URL,\n    segments: string[],\n    results: Array<{ match: PatternMatch<any>; state: MatchState }>,\n    protocolParams: Record<string, string>,\n    urlSearch: string | undefined,\n    earlyExit: boolean,\n  ): void {\n    // Parse hostname into reversed labels\n    let hostname = url.hostname.toLowerCase()\n    let hostnameLabels = hostname.split('.').reverse()\n\n    // Find matching hostname nodes\n    let hostnameMatches = this.#matchHostnameLabels(protocolNode.hostnameRoot, hostnameLabels, 0, {\n      ...protocolParams,\n    })\n\n    for (let { node: hostnameNode, params: hostnameParams } of hostnameMatches) {\n      // Try port-specific pathname tries\n      if (url.port) {\n        let portTrie = hostnameNode.portChildren.get(url.port)\n        if (portTrie) {\n          this.#matchPathnameInTrie(\n            portTrie,\n            segments,\n            hostnameParams,\n            results,\n            urlSearch,\n            earlyExit,\n          )\n        }\n      }\n\n      // Try default pathname trie (matches any port or no port)\n      if (hostnameNode.defaultPathnameTrie) {\n        this.#matchPathnameInTrie(\n          hostnameNode.defaultPathnameTrie,\n          segments,\n          hostnameParams,\n          results,\n          urlSearch,\n          earlyExit,\n        )\n      }\n    }\n  }\n\n  #matchHostnameLabels(\n    node: HostnameTrieNode,\n    labels: string[],\n    labelIndex: number,\n    params: Record<string, string>,\n  ): Array<{ node: HostnameTrieNode; params: Record<string, string> }> {\n    let results: Array<{ node: HostnameTrieNode; params: Record<string, string> }> = []\n\n    // If we've consumed all labels, this is a potential match\n    if (labelIndex >= labels.length) {\n      results.push({ node, params })\n      return results\n    }\n\n    let currentLabel = labels[labelIndex]\n\n    // Try static children\n    let staticChild = node.staticChildren.get(currentLabel)\n    if (staticChild) {\n      results.push(...this.#matchHostnameLabels(staticChild, labels, labelIndex + 1, params))\n    }\n\n    // Try variable child\n    if (node.variableChild) {\n      let newParams = { ...params }\n      newParams[node.variableChild.paramName] = currentLabel\n      results.push(\n        ...this.#matchHostnameLabels(node.variableChild.node, labels, labelIndex + 1, newParams),\n      )\n    }\n\n    // Try wildcard child (consumes remaining labels)\n    if (node.wildcardChild) {\n      let remainingLabels = labels.slice(labelIndex).reverse().join('.')\n      let newParams = { ...params }\n      if (node.wildcardChild.paramName) {\n        newParams[node.wildcardChild.paramName] = remainingLabels\n      }\n      results.push({ node: node.wildcardChild.node, params: newParams })\n    }\n\n    return results\n  }\n\n  #matchPathnameInTrie(\n    pathnameTrie: TrieNode,\n    segments: string[],\n    hostnameParams: Record<string, string>,\n    results: Array<{ match: PatternMatch<any>; state: MatchState }>,\n    urlSearch: string | undefined,\n    earlyExit: boolean,\n  ): void {\n    let initialState: MatchState = {\n      segments,\n      segmentIndex: 0,\n      params: { ...hostnameParams },\n      specificity: 1000, // Origin patterns get higher base specificity\n      nodeId: pathnameTrie.id,\n    }\n\n    let traversalResults = this.#bestFirstTraversal(\n      pathnameTrie,\n      initialState,\n      earlyExit,\n      urlSearch,\n    )\n    results.push(...traversalResults)\n  }\n\n  #matchSearch(search: string, constraints: SearchConstraints): boolean {\n    let { namesWithoutAssignment, namesWithAssignment, valuesByKey } = parseSearch(search)\n\n    for (let [key, constraint] of constraints) {\n      let hasAssigned = namesWithAssignment.has(key)\n      let hasBare = namesWithoutAssignment.has(key)\n      let values = valuesByKey.get(key)\n\n      if (constraint.requiredValues && constraint.requiredValues.size > 0) {\n        if (!values) return false\n        for (let value of constraint.requiredValues) {\n          if (!values.has(value)) return false\n        }\n        continue\n      }\n\n      if (constraint.requireAssignment) {\n        if (!hasAssigned) return false\n        continue\n      }\n\n      if (!(hasAssigned || hasBare)) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Best-first traversal with priority queue\n   * Returns results sorted by combined specificity (highest first)\n   * If earlyExit is true, returns immediately after finding first valid match\n   */\n  #bestFirstTraversal(\n    startNode: TrieNode,\n    startState: MatchState,\n    earlyExit: boolean,\n    urlSearch?: string,\n  ): Array<{ match: PatternMatch<any>; state: MatchState }> {\n    let results: Array<{ match: PatternMatch<any>; state: MatchState }> = []\n    let bestSpec = earlyExit ? -Infinity : 0 // Track best for pruning\n\n    // Stack for DFS: high priority first\n    let stack: TraversalState[] = []\n    let initial: TraversalState = {\n      node: startNode,\n      state: startState,\n      priority: this.#calculatePriority(startNode, startState),\n    }\n    stack.push(initial)\n\n    let visited = new Set<string>()\n    let statesExplored = 0\n\n    while (stack.length > 0 && statesExplored < this.#maxTraversalStates) {\n      let current = stack.pop()!\n      statesExplored++\n\n      let { node, state } = current\n\n      let dedupKey = `${state.nodeId ?? node.id}:${state.segmentIndex}`\n      if (state.wildcardSpan) {\n        dedupKey += `:${state.wildcardSpan}`\n      }\n\n      if (visited.has(dedupKey)) continue\n      visited.add(dedupKey)\n\n      // Prune if low priority and earlyExit\n      if (earlyExit && state.specificity < bestSpec - 100) continue // Threshold for low spec\n\n      if (state.segmentIndex === state.segments.length) {\n        for (let pattern of node.patterns) {\n          if (pattern.searchConstraints) {\n            let searchToMatch = urlSearch ?? ''\n            if (!this.#matchSearch(searchToMatch, pattern.searchConstraints)) continue\n          }\n\n          let score = this.#finalScore(pattern, state)\n          results.push({ match: pattern, state: { ...state } })\n          if (earlyExit) {\n            bestSpec = Math.max(bestSpec, score)\n            // Sort results if multiple, but early exit after first batch\n            if (results.length > 1)\n              results.sort(\n                (a, b) => this.#finalScore(b.match, b.state) - this.#finalScore(a.match, a.state),\n              )\n            return results.slice(0, 1) // Only best\n          }\n        }\n      }\n\n      // Optional edges\n      let optionalStates: TraversalState[] = []\n      for (let optionalEdge of node.optionalEdges) {\n        this.#expandOptionalStates(optionalEdge, node, state, optionalStates, earlyExit, bestSpec)\n      }\n      // Prune low priority\n      optionalStates = optionalStates.filter((s) => !earlyExit || s.priority >= bestSpec - 50)\n      optionalStates.sort((a, b) => b.priority - a.priority)\n      for (let i = optionalStates.length - 1; i >= 0; i--) {\n        stack.push(optionalStates[i])\n      }\n\n      if (state.segmentIndex >= state.segments.length) continue\n\n      let childStates: TraversalState[] = []\n      this.#expandTraversalState(node, state, childStates, earlyExit, bestSpec)\n      // Prune low\n      childStates = childStates.filter((s) => !earlyExit || s.priority >= bestSpec - 50)\n      childStates.sort((a, b) => b.priority - a.priority)\n      for (let i = childStates.length - 1; i >= 0; i--) {\n        stack.push(childStates[i])\n      }\n    }\n\n    results.sort((a, b) => this.#finalScore(b.match, b.state) - this.#finalScore(a.match, a.state))\n    return results\n  }\n\n  #calculatePriority(node: TrieNode, state: MatchState): number {\n    let currentSpecificity = state.specificity\n    let remainingSegments = state.segments.length - state.segmentIndex\n\n    let estimatedRemaining = 0\n    if (node.minDepthToTerminal !== undefined && remainingSegments > 0) {\n      // Better: assume mix of static/var: avg 50 per segment\n      estimatedRemaining = Math.min(remainingSegments, node.minDepthToTerminal) * 50\n    } else {\n      estimatedRemaining = remainingSegments * 50 // Default avg\n    }\n\n    return currentSpecificity + estimatedRemaining\n  }\n\n  #getStaticChild(node: TrieNode, segment: string): TrieNode | undefined {\n    let child = node.staticChildren.get(segment)\n    if (!child && node.hasIgnoreCasePatterns) {\n      child = node.staticChildren.get(segment.toLowerCase())\n    }\n    return child\n  }\n\n  #expandTraversalState(\n    node: TrieNode,\n    state: MatchState,\n    states: TraversalState[], // Collect\n    earlyExit: boolean,\n    bestSpec: number,\n  ): void {\n    let currentSegment = state.segments[state.segmentIndex]\n\n    // Try static children first (highest priority)\n    let staticChild = this.#getStaticChild(node, currentSegment)\n\n    if (staticChild) {\n      let newState: MatchState = {\n        ...state,\n        segmentIndex: state.segmentIndex + 1,\n        specificity: state.specificity + 100,\n        nodeId: staticChild.id,\n      }\n      let ts: TraversalState = {\n        node: staticChild,\n        state: newState,\n        priority: this.#calculatePriority(staticChild, newState),\n      }\n      if (!earlyExit || ts.priority >= bestSpec - 50) {\n        states.push(ts)\n      }\n    }\n\n    // Try shape children\n    for (let [shapeKey, shapeEntry] of node.shapeChildren) {\n      let matchResult = this.#matchShape(shapeEntry, currentSegment)\n      if (matchResult) {\n        let newState: MatchState = {\n          ...state,\n          segmentIndex: state.segmentIndex + 1,\n          params: { ...state.params, ...matchResult.params },\n          specificity: state.specificity + matchResult.specificity,\n          nodeId: shapeEntry.node.id,\n        }\n        let ts: TraversalState = {\n          node: shapeEntry.node,\n          state: newState,\n          priority: this.#calculatePriority(shapeEntry.node, newState),\n        }\n        if (!earlyExit || ts.priority >= bestSpec - 50) {\n          states.push(ts)\n        }\n      }\n    }\n\n    // Try variable child\n    if (node.variableChild) {\n      let newParams = { ...state.params }\n      newParams[node.variableChild.paramName] = currentSegment\n      let newState: MatchState = {\n        ...state,\n        segmentIndex: state.segmentIndex + 1,\n        params: newParams,\n        specificity: state.specificity + 10,\n        nodeId: node.variableChild.id,\n      }\n      let ts: TraversalState = {\n        node: node.variableChild,\n        state: newState,\n        priority: this.#calculatePriority(node.variableChild, newState),\n      }\n      if (!earlyExit || ts.priority >= bestSpec - 50) {\n        states.push(ts)\n      }\n    }\n\n    // Try wildcard edge\n    if (node.wildcardEdge) {\n      this.#expandWildcardStates(node.wildcardEdge, state, states, earlyExit, bestSpec)\n    }\n  }\n\n  #expandOptionalStates(\n    optionalEdge: OptionalEdge,\n    currentNode: TrieNode,\n    state: MatchState,\n    states: TraversalState[], // Now collects\n    earlyExit: boolean,\n    bestSpec: number,\n  ): void {\n    // Option 1: Skip the optional, go directly to continuation\n    let skipState: MatchState = {\n      ...state,\n      nodeId: optionalEdge.continuation.id,\n      // Lower priority for skipping (less specific)\n      specificity: state.specificity - 1,\n    }\n    let skipTraversal: TraversalState = {\n      node: optionalEdge.continuation,\n      state: skipState,\n      priority: this.#calculatePriority(optionalEdge.continuation, skipState),\n    }\n    if (!earlyExit || skipTraversal.priority >= bestSpec - 50) {\n      states.push(skipTraversal)\n    }\n  }\n\n  #expandWildcardStates(\n    wildcardEdge: WildcardEdge,\n    state: MatchState,\n    states: TraversalState[],\n    earlyExit: boolean,\n    bestSpec: number,\n  ): void {\n    let remaining = state.segments.length - state.segmentIndex\n    let continuation = wildcardEdge.continuation\n    let minConsume = 0\n    let maxConsume = remaining\n\n    if (continuation.minDepthToTerminal !== undefined) {\n      maxConsume = Math.min(maxConsume, remaining - continuation.minDepthToTerminal)\n    }\n    if (continuation.maxDepthToTerminal !== undefined) {\n      minConsume = Math.max(minConsume, remaining - continuation.maxDepthToTerminal)\n    }\n\n    if (minConsume > maxConsume) return\n\n    // Greedy-first: try larger consumption counts first\n    for (let consumeCount = maxConsume; consumeCount >= minConsume; consumeCount--) {\n      let consumedSegments = state.segments.slice(\n        state.segmentIndex,\n        state.segmentIndex + consumeCount,\n      )\n      let newParams = { ...state.params }\n      if (wildcardEdge.paramName) {\n        newParams[wildcardEdge.paramName] = consumedSegments.join('/')\n      }\n      let newState: MatchState = {\n        ...state,\n        segmentIndex: state.segmentIndex + consumeCount,\n        params: newParams,\n        specificity: state.specificity + 1,\n        nodeId: continuation.id,\n        wildcardSpan: `${state.segmentIndex}-${state.segmentIndex + consumeCount}`,\n      }\n      let ts: TraversalState = {\n        node: continuation,\n        state: newState,\n        priority: this.#calculatePriority(continuation, newState),\n      }\n      if (!earlyExit || ts.priority >= bestSpec - 50) {\n        states.push(ts)\n      }\n    }\n  }\n\n  #tryOriginMatch(parsedUrl: ParsedURL, segments: string[], urlObj: URL): MatchResult<T> | null {\n    let results = this.#findOriginMatches(urlObj, segments, parsedUrl.search, true)\n    if (results.length > 0) {\n      let best = results[0]\n      return { data: best.match.node, params: best.state.params, url: urlObj }\n    }\n    return null\n  }\n\n  #tryPathnameMatch(\n    pathnameTrie: TrieNode,\n    segments: string[],\n    baseParams: Record<string, string>,\n    search: string,\n    urlObj: URL,\n  ): MatchResult<T> | null {\n    let initialState: MatchState = {\n      segments,\n      segmentIndex: 0,\n      params: { ...baseParams },\n      specificity: 1000,\n      nodeId: pathnameTrie.id,\n    }\n    let results = this.#bestFirstTraversal(pathnameTrie, initialState, true, search)\n    if (results.length > 0) {\n      let best = results[0]\n      return { data: best.match.node, params: best.state.params, url: urlObj }\n    }\n    return null\n  }\n\n  #tryStaticPathMatch(segments: string[], search: string, url: URL): MatchResult<T> | null {\n    let results = this.#walkStaticPath(segments, search, false)\n    if (results.length > 0) {\n      let best = results[0]\n      return { data: best.match.node, params: {}, url }\n    }\n    return null\n  }\n\n  #tryStaticPathAll(\n    segments: string[],\n    search: string,\n    url: URL,\n  ): { match: PatternMatch<any>; state: MatchState }[] {\n    return this.#walkStaticPath(segments, search, true)\n  }\n\n  #walkStaticPath(\n    segments: string[],\n    search: string,\n    collectAll: boolean,\n  ): { match: PatternMatch<any>; state: MatchState }[] {\n    let current = this.#pathnameOnlyRoot\n    let pathNodes: TrieNode[] = collectAll ? [current] : []\n\n    for (let seg of segments) {\n      let child = this.#getStaticChild(current, seg)\n      if (!child) return []\n      current = child\n      if (collectAll) pathNodes.push(current)\n    }\n\n    let matches: { match: PatternMatch<any>; state: MatchState }[] = []\n    let nodesToCheck = collectAll ? pathNodes : [current]\n\n    for (let node of nodesToCheck) {\n      for (let pattern of node.patterns) {\n        if (pattern.searchConstraints && !this.#matchSearch(search, pattern.searchConstraints))\n          continue\n        let state: MatchState = {\n          segments,\n          segmentIndex: segments.length,\n          params: {},\n          specificity: 0,\n          nodeId: node.id,\n        }\n        matches.push({ match: pattern, state })\n        if (!collectAll) return matches\n      }\n    }\n\n    return matches.sort((a, b) => b.match.specificity - a.match.specificity)\n  }\n}\n"],
  "mappings": "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",
  "names": ["name", "existing", "tokens", "finalNode"]
}
